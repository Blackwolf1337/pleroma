{"version":3,"sources":["webpack:///sw.js","webpack:///webpack/bootstrap 6dbbd6a780c64df31844","webpack:///./src/sw.js","webpack:///./~/localforage/dist/localforage.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","isEnabled","localForage","getItem","then","data","config","webPushNotifications","getWindowClients","clients","matchAll","includeUncontrolled","clientList","filter","_ref","type","_localforage","_localforage2","self","addEventListener","event","waitUntil","list","json","length","registration","showNotification","title","notification","close","i","client","url","focus","openWindow","f","define","amd","g","window","global","this","localforage","e","t","n","r","s","o","u","a","require","Error","code","l","1","_dereq_","nextTick","draining","oldQueue","len","queue","immediate","task","push","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","document","createTextNode","observe","characterData","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","2","INTERNAL","Promise","resolver","TypeError","state","PENDING","outcome","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","value","returnValue","handlers","reject","resolve","getThen","apply","arguments","thenable","onError","onSuccess","tryToUnwrap","result","tryCatch","status","out","reason","all","iterable","allResolver","resolveFromAll","outValue","values","resolved","error","Object","prototype","toString","Array","race","response","REJECTED","FULFILLED","constructor","3","4","_classCallCheck","instance","Constructor","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","isIndexedDBValid","idb","isSafari","openDatabase","test","navigator","userAgent","platform","hasFetch","fetch","indexOf","IDBKeyRange","createBlob","parts","properties","Blob","name","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","executeCallback","callback","executeTwoCallbacks","errorCallback","normalizeKey","key","console","warn","String","_binStringToArrayBuffer","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","_checkBlobSupportWithoutCaching","Promise$1","txn","transaction","DETECT_BLOB_SUPPORT_STORE","READ_WRITE","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","match","matchedEdge","parseInt","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_rejectReadiness","err","_getConnection","upgradeNeeded","db","dbArgs","version","openreq","open","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","newVersion","onerror","onsuccess","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","base64","btoa","target","__local_forage_encoded_blob","readAsBinaryString","_decodeBlob","encodedBlob","arrayBuff","atob","_isEncodedBlob","_fullyReady","_initReady","_dbInfo","_tryReconnect","forages","j","createTransaction","mode","tx","_initStorage","options","ignoreErrors","ready","initPromises","forage","slice","_defaultConfig","k","READ_ONLY","store","req","get","undefined","iterate","iterator","openCursor","iterationNumber","cursor","setItem","blobSupport","removeItem","clear","count","advanced","advance","keys","isWebSQLValid","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","buffer","bytes","BASE_CHARS","bufferToString","base64String","substring","serialize","valueType","toString$1","marker","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","onload","str","BLOB_TYPE_PREFIX","TYPE_BLOB","readAsArrayBuffer","JSON","stringify","deserialize","SERIALIZED_MARKER_LENGTH","parse","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_initStorage$1","dbInfoPromise","description","size","executeSql","serializer","localforageSerializer","getItem$1","results","rows","item","iterate$1","_setItem","retriesLeft","originalValue","sqlError","QUOTA_ERR","setItem$1","removeItem$1","clear$1","length$1","key$1","keys$1","isLocalStorageValid","localStorage","checkIfLocalStorageThrows","localStorageTestKey","_isLocalStorageUsable","_initStorage$2","keyPrefix","clear$2","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","itemKey","length$2","removeItem$2","setItem$2","callWhenReady","localForageInstance","libraryMethod","_args","extend","arg","_key","hasOwnProperty","isArray","_typeof","Symbol","asyncStorage","_driver","_support","webSQLStorage","localStorageWrapper","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","LibraryMethods","DefaultConfig","driver","LocalForage","driverTypeKey","driverName","defineDriver","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","replace","driverObject","complianceError","driverMethods","concat","customDriverMethod","setDriverSupport","support","info","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","extendSelfWithDriver","_extend","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_getSupportedDrivers","oldDriverSetDone","supports","libraryMethodsAndProperties","createInstance","localforage_js"],"mappings":"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","file":"sw.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _localforage = __webpack_require__(1);\n\t\n\tvar _localforage2 = _interopRequireDefault(_localforage);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction isEnabled() {\n\t  return _localforage2.default.getItem('vuex-lz').then(function (data) {\n\t    return data.config.webPushNotifications;\n\t  });\n\t}\n\t\n\tfunction getWindowClients() {\n\t  return clients.matchAll({ includeUncontrolled: true }).then(function (clientList) {\n\t    return clientList.filter(function (_ref) {\n\t      var type = _ref.type;\n\t      return type === 'window';\n\t    });\n\t  });\n\t}\n\t\n\tself.addEventListener('push', function (event) {\n\t  if (event.data) {\n\t    event.waitUntil(isEnabled().then(function (isEnabled) {\n\t      return isEnabled && getWindowClients().then(function (list) {\n\t        var data = event.data.json();\n\t\n\t        if (list.length === 0) return self.registration.showNotification(data.title, data);\n\t      });\n\t    }));\n\t  }\n\t});\n\t\n\tself.addEventListener('notificationclick', function (event) {\n\t  event.notification.close();\n\t\n\t  event.waitUntil(getWindowClients().then(function (list) {\n\t    for (var i = 0; i < list.length; i++) {\n\t      var client = list[i];\n\t      if (client.url === '/' && 'focus' in client) {\n\t        return client.focus();\n\t      }\n\t    }\n\t\n\t    if (clients.openWindow) return clients.openWindow('/');\n\t  }));\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*!\n\t    localForage -- Offline Storage, Improved\n\t    Version 1.5.6\n\t    https://localforage.github.io/localForage\n\t    (c) 2013-2017 Mozilla, Apache License 2.0\n\t*/\n\t(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\t(function (global){\n\t'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\t},{}],2:[function(_dereq_,module,exports){\n\t'use strict';\n\tvar immediate = _dereq_(1);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype[\"catch\"] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t},{\"1\":1}],3:[function(_dereq_,module,exports){\n\t(function (global){\n\t'use strict';\n\tif (typeof global.Promise !== 'function') {\n\t  global.Promise = _dereq_(2);\n\t}\n\t\n\t}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\t},{\"2\":2}],4:[function(_dereq_,module,exports){\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction getIDB() {\n\t    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n\t    try {\n\t        if (typeof indexedDB !== 'undefined') {\n\t            return indexedDB;\n\t        }\n\t        if (typeof webkitIndexedDB !== 'undefined') {\n\t            return webkitIndexedDB;\n\t        }\n\t        if (typeof mozIndexedDB !== 'undefined') {\n\t            return mozIndexedDB;\n\t        }\n\t        if (typeof OIndexedDB !== 'undefined') {\n\t            return OIndexedDB;\n\t        }\n\t        if (typeof msIndexedDB !== 'undefined') {\n\t            return msIndexedDB;\n\t        }\n\t    } catch (e) {\n\t        return;\n\t    }\n\t}\n\t\n\tvar idb = getIDB();\n\t\n\tfunction isIndexedDBValid() {\n\t    try {\n\t        // Initialize IndexedDB; fall back to vendor-prefixed versions\n\t        // if needed.\n\t        if (!idb) {\n\t            return false;\n\t        }\n\t        // We mimic PouchDB here;\n\t        //\n\t        // We test for openDatabase because IE Mobile identifies itself\n\t        // as Safari. Oh the lulz...\n\t        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\t\n\t        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\t\n\t        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n\t        // since Safari 10.1 shipped with fetch, we can use that to detect it\n\t        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n\t        // some outdated implementations of IDB that appear on Samsung\n\t        // and HTC Android devices <4.4 are missing IDBKeyRange\n\t        // See: https://github.com/mozilla/localForage/issues/128\n\t        // See: https://github.com/mozilla/localForage/issues/272\n\t        typeof IDBKeyRange !== 'undefined';\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor. (i.e.\n\t// old QtWebKit versions, at least).\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor. (i.e.\n\t// old QtWebKit versions, at least).\n\tfunction createBlob(parts, properties) {\n\t    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t    parts = parts || [];\n\t    properties = properties || {};\n\t    try {\n\t        return new Blob(parts, properties);\n\t    } catch (e) {\n\t        if (e.name !== 'TypeError') {\n\t            throw e;\n\t        }\n\t        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n\t        var builder = new Builder();\n\t        for (var i = 0; i < parts.length; i += 1) {\n\t            builder.append(parts[i]);\n\t        }\n\t        return builder.getBlob(properties.type);\n\t    }\n\t}\n\t\n\t// This is CommonJS because lie is an external dependency, so Rollup\n\t// can just ignore it.\n\tif (typeof Promise === 'undefined') {\n\t    // In the \"nopromises\" build this will just throw if you don't have\n\t    // a global promise object, but it would throw anyway later.\n\t    _dereq_(3);\n\t}\n\tvar Promise$1 = Promise;\n\t\n\tfunction executeCallback(promise, callback) {\n\t    if (callback) {\n\t        promise.then(function (result) {\n\t            callback(null, result);\n\t        }, function (error) {\n\t            callback(error);\n\t        });\n\t    }\n\t}\n\t\n\tfunction executeTwoCallbacks(promise, callback, errorCallback) {\n\t    if (typeof callback === 'function') {\n\t        promise.then(callback);\n\t    }\n\t\n\t    if (typeof errorCallback === 'function') {\n\t        promise[\"catch\"](errorCallback);\n\t    }\n\t}\n\t\n\tfunction normalizeKey(key) {\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    return key;\n\t}\n\t\n\t// Some code originally from async_storage.js in\n\t// [Gaia](https://github.com/mozilla-b2g/gaia).\n\t\n\tvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\n\tvar supportsBlobs;\n\tvar dbContexts;\n\tvar toString = Object.prototype.toString;\n\t\n\t// Transaction Modes\n\tvar READ_ONLY = 'readonly';\n\tvar READ_WRITE = 'readwrite';\n\t\n\t// Transform a binary string to an array buffer, because otherwise\n\t// weird stuff happens when you try to work with the binary string directly.\n\t// It is known.\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction _binStringToArrayBuffer(bin) {\n\t    var length = bin.length;\n\t    var buf = new ArrayBuffer(length);\n\t    var arr = new Uint8Array(buf);\n\t    for (var i = 0; i < length; i++) {\n\t        arr[i] = bin.charCodeAt(i);\n\t    }\n\t    return buf;\n\t}\n\t\n\t//\n\t// Blobs are not supported in all versions of IndexedDB, notably\n\t// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n\t//\n\t// Various other blob bugs exist in Chrome v37-42 (inclusive).\n\t// Detecting them is expensive and confusing to users, and Chrome 37-42\n\t// is at very low usage worldwide, so we do a hacky userAgent check instead.\n\t//\n\t// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\t// Code borrowed from PouchDB. See:\n\t// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n\t//\n\tfunction _checkBlobSupportWithoutCaching(idb) {\n\t    return new Promise$1(function (resolve) {\n\t        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n\t        var blob = createBlob(['']);\n\t        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\t\n\t        txn.onabort = function (e) {\n\t            // If the transaction aborts now its due to not being able to\n\t            // write to the database, likely due to the disk being full\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            resolve(false);\n\t        };\n\t\n\t        txn.oncomplete = function () {\n\t            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n\t            // MS Edge pretends to be Chrome 42:\n\t            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\t            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n\t        };\n\t    })[\"catch\"](function () {\n\t        return false; // error, so assume unsupported\n\t    });\n\t}\n\t\n\tfunction _checkBlobSupport(idb) {\n\t    if (typeof supportsBlobs === 'boolean') {\n\t        return Promise$1.resolve(supportsBlobs);\n\t    }\n\t    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n\t        supportsBlobs = value;\n\t        return supportsBlobs;\n\t    });\n\t}\n\t\n\tfunction _deferReadiness(dbInfo) {\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // Create a deferred object representing the current database operation.\n\t    var deferredOperation = {};\n\t\n\t    deferredOperation.promise = new Promise$1(function (resolve) {\n\t        deferredOperation.resolve = resolve;\n\t    });\n\t\n\t    // Enqueue the deferred operation.\n\t    dbContext.deferredOperations.push(deferredOperation);\n\t\n\t    // Chain its promise to the database readiness.\n\t    if (!dbContext.dbReady) {\n\t        dbContext.dbReady = deferredOperation.promise;\n\t    } else {\n\t        dbContext.dbReady = dbContext.dbReady.then(function () {\n\t            return deferredOperation.promise;\n\t        });\n\t    }\n\t}\n\t\n\tfunction _advanceReadiness(dbInfo) {\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // Dequeue a deferred operation.\n\t    var deferredOperation = dbContext.deferredOperations.pop();\n\t\n\t    // Resolve its promise (which is part of the database readiness\n\t    // chain of promises).\n\t    if (deferredOperation) {\n\t        deferredOperation.resolve();\n\t    }\n\t}\n\t\n\tfunction _rejectReadiness(dbInfo, err) {\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // Dequeue a deferred operation.\n\t    var deferredOperation = dbContext.deferredOperations.pop();\n\t\n\t    // Reject its promise (which is part of the database readiness\n\t    // chain of promises).\n\t    if (deferredOperation) {\n\t        deferredOperation.reject(err);\n\t    }\n\t}\n\t\n\tfunction _getConnection(dbInfo, upgradeNeeded) {\n\t    return new Promise$1(function (resolve, reject) {\n\t\n\t        if (dbInfo.db) {\n\t            if (upgradeNeeded) {\n\t                _deferReadiness(dbInfo);\n\t                dbInfo.db.close();\n\t            } else {\n\t                return resolve(dbInfo.db);\n\t            }\n\t        }\n\t\n\t        var dbArgs = [dbInfo.name];\n\t\n\t        if (upgradeNeeded) {\n\t            dbArgs.push(dbInfo.version);\n\t        }\n\t\n\t        var openreq = idb.open.apply(idb, dbArgs);\n\t\n\t        if (upgradeNeeded) {\n\t            openreq.onupgradeneeded = function (e) {\n\t                var db = openreq.result;\n\t                try {\n\t                    db.createObjectStore(dbInfo.storeName);\n\t                    if (e.oldVersion <= 1) {\n\t                        // Added when support for blob shims was added\n\t                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t                    }\n\t                } catch (ex) {\n\t                    if (ex.name === 'ConstraintError') {\n\t                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n\t                    } else {\n\t                        throw ex;\n\t                    }\n\t                }\n\t            };\n\t        }\n\t\n\t        openreq.onerror = function (e) {\n\t            e.preventDefault();\n\t            reject(openreq.error);\n\t        };\n\t\n\t        openreq.onsuccess = function () {\n\t            resolve(openreq.result);\n\t            _advanceReadiness(dbInfo);\n\t        };\n\t    });\n\t}\n\t\n\tfunction _getOriginalConnection(dbInfo) {\n\t    return _getConnection(dbInfo, false);\n\t}\n\t\n\tfunction _getUpgradedConnection(dbInfo) {\n\t    return _getConnection(dbInfo, true);\n\t}\n\t\n\tfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n\t    if (!dbInfo.db) {\n\t        return true;\n\t    }\n\t\n\t    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n\t    var isDowngrade = dbInfo.version < dbInfo.db.version;\n\t    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\t\n\t    if (isDowngrade) {\n\t        // If the version is not the default one\n\t        // then warn for impossible downgrade.\n\t        if (dbInfo.version !== defaultVersion) {\n\t            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n\t        }\n\t        // Align the versions to prevent errors.\n\t        dbInfo.version = dbInfo.db.version;\n\t    }\n\t\n\t    if (isUpgrade || isNewStore) {\n\t        // If the store is new then increment the version (if needed).\n\t        // This will trigger an \"upgradeneeded\" event which is required\n\t        // for creating a store.\n\t        if (isNewStore) {\n\t            var incVersion = dbInfo.db.version + 1;\n\t            if (incVersion > dbInfo.version) {\n\t                dbInfo.version = incVersion;\n\t            }\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\t// encode a blob for indexeddb engines that don't support blobs\n\tfunction _encodeBlob(blob) {\n\t    return new Promise$1(function (resolve, reject) {\n\t        var reader = new FileReader();\n\t        reader.onerror = reject;\n\t        reader.onloadend = function (e) {\n\t            var base64 = btoa(e.target.result || '');\n\t            resolve({\n\t                __local_forage_encoded_blob: true,\n\t                data: base64,\n\t                type: blob.type\n\t            });\n\t        };\n\t        reader.readAsBinaryString(blob);\n\t    });\n\t}\n\t\n\t// decode an encoded blob\n\tfunction _decodeBlob(encodedBlob) {\n\t    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n\t    return createBlob([arrayBuff], { type: encodedBlob.type });\n\t}\n\t\n\t// is this one of our fancy encoded blobs?\n\tfunction _isEncodedBlob(value) {\n\t    return value && value.__local_forage_encoded_blob;\n\t}\n\t\n\t// Specialize the default `ready()` function by making it dependent\n\t// on the current database operations. Thus, the driver will be actually\n\t// ready when it's been initialized (default) *and* there are no pending\n\t// operations on the database (initiated by some other instances).\n\tfunction _fullyReady(callback) {\n\t    var self = this;\n\t\n\t    var promise = self._initReady().then(function () {\n\t        var dbContext = dbContexts[self._dbInfo.name];\n\t\n\t        if (dbContext && dbContext.dbReady) {\n\t            return dbContext.dbReady;\n\t        }\n\t    });\n\t\n\t    executeTwoCallbacks(promise, callback, callback);\n\t    return promise;\n\t}\n\t\n\t// Try to establish a new db connection to replace the\n\t// current one which is broken (i.e. experiencing\n\t// InvalidStateError while creating a transaction).\n\tfunction _tryReconnect(dbInfo) {\n\t    _deferReadiness(dbInfo);\n\t\n\t    var dbContext = dbContexts[dbInfo.name];\n\t    var forages = dbContext.forages;\n\t\n\t    for (var i = 0; i < forages.length; i++) {\n\t        if (forages[i]._dbInfo.db) {\n\t            forages[i]._dbInfo.db.close();\n\t            forages[i]._dbInfo.db = null;\n\t        }\n\t    }\n\t\n\t    return _getConnection(dbInfo, false).then(function (db) {\n\t        for (var j = 0; j < forages.length; j++) {\n\t            forages[j]._dbInfo.db = db;\n\t        }\n\t    })[\"catch\"](function (err) {\n\t        _rejectReadiness(dbInfo, err);\n\t        throw err;\n\t    });\n\t}\n\t\n\t// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n\t// so we have to do it with callbacks\n\tfunction createTransaction(dbInfo, mode, callback) {\n\t    try {\n\t        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n\t        callback(null, tx);\n\t    } catch (err) {\n\t        if (!dbInfo.db || err.name === 'InvalidStateError') {\n\t            return _tryReconnect(dbInfo).then(function () {\n\t\n\t                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n\t                callback(null, tx);\n\t            });\n\t        }\n\t\n\t        callback(err);\n\t    }\n\t}\n\t\n\t// Open the IndexedDB database (automatically creates one if one didn't\n\t// previously exist), using any options set in the config.\n\tfunction _initStorage(options) {\n\t    var self = this;\n\t    var dbInfo = {\n\t        db: null\n\t    };\n\t\n\t    if (options) {\n\t        for (var i in options) {\n\t            dbInfo[i] = options[i];\n\t        }\n\t    }\n\t\n\t    // Initialize a singleton container for all running localForages.\n\t    if (!dbContexts) {\n\t        dbContexts = {};\n\t    }\n\t\n\t    // Get the current context of the database;\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // ...or create a new context.\n\t    if (!dbContext) {\n\t        dbContext = {\n\t            // Running localForages sharing a database.\n\t            forages: [],\n\t            // Shared database.\n\t            db: null,\n\t            // Database readiness (promise).\n\t            dbReady: null,\n\t            // Deferred operations on the database.\n\t            deferredOperations: []\n\t        };\n\t        // Register the new context in the global container.\n\t        dbContexts[dbInfo.name] = dbContext;\n\t    }\n\t\n\t    // Register itself as a running localForage in the current context.\n\t    dbContext.forages.push(self);\n\t\n\t    // Replace the default `ready()` function with the specialized one.\n\t    if (!self._initReady) {\n\t        self._initReady = self.ready;\n\t        self.ready = _fullyReady;\n\t    }\n\t\n\t    // Create an array of initialization states of the related localForages.\n\t    var initPromises = [];\n\t\n\t    function ignoreErrors() {\n\t        // Don't handle errors here,\n\t        // just makes sure related localForages aren't pending.\n\t        return Promise$1.resolve();\n\t    }\n\t\n\t    for (var j = 0; j < dbContext.forages.length; j++) {\n\t        var forage = dbContext.forages[j];\n\t        if (forage !== self) {\n\t            // Don't wait for itself...\n\t            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n\t        }\n\t    }\n\t\n\t    // Take a snapshot of the related localForages.\n\t    var forages = dbContext.forages.slice(0);\n\t\n\t    // Initialize the connection process only when\n\t    // all the related localForages aren't pending.\n\t    return Promise$1.all(initPromises).then(function () {\n\t        dbInfo.db = dbContext.db;\n\t        // Get the connection or open a new one without upgrade.\n\t        return _getOriginalConnection(dbInfo);\n\t    }).then(function (db) {\n\t        dbInfo.db = db;\n\t        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n\t            // Reopen the database for upgrading.\n\t            return _getUpgradedConnection(dbInfo);\n\t        }\n\t        return db;\n\t    }).then(function (db) {\n\t        dbInfo.db = dbContext.db = db;\n\t        self._dbInfo = dbInfo;\n\t        // Share the final connection amongst related localForages.\n\t        for (var k = 0; k < forages.length; k++) {\n\t            var forage = forages[k];\n\t            if (forage !== self) {\n\t                // Self is already up-to-date.\n\t                forage._dbInfo.db = dbInfo.db;\n\t                forage._dbInfo.version = dbInfo.version;\n\t            }\n\t        }\n\t    });\n\t}\n\t\n\tfunction getItem(key, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    var req = store.get(key);\n\t\n\t                    req.onsuccess = function () {\n\t                        var value = req.result;\n\t                        if (value === undefined) {\n\t                            value = null;\n\t                        }\n\t                        if (_isEncodedBlob(value)) {\n\t                            value = _decodeBlob(value);\n\t                        }\n\t                        resolve(value);\n\t                    };\n\t\n\t                    req.onerror = function () {\n\t                        reject(req.error);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Iterate over all items stored in database.\n\tfunction iterate(iterator, callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    var req = store.openCursor();\n\t                    var iterationNumber = 1;\n\t\n\t                    req.onsuccess = function () {\n\t                        var cursor = req.result;\n\t\n\t                        if (cursor) {\n\t                            var value = cursor.value;\n\t                            if (_isEncodedBlob(value)) {\n\t                                value = _decodeBlob(value);\n\t                            }\n\t                            var result = iterator(value, cursor.key, iterationNumber++);\n\t\n\t                            // when the iterator callback retuns any\n\t                            // (non-`undefined`) value, then we stop\n\t                            // the iteration immediately\n\t                            if (result !== void 0) {\n\t                                resolve(result);\n\t                            } else {\n\t                                cursor[\"continue\"]();\n\t                            }\n\t                        } else {\n\t                            resolve();\n\t                        }\n\t                    };\n\t\n\t                    req.onerror = function () {\n\t                        reject(req.error);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t\n\t    return promise;\n\t}\n\t\n\tfunction setItem(key, value, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        var dbInfo;\n\t        self.ready().then(function () {\n\t            dbInfo = self._dbInfo;\n\t            if (toString.call(value) === '[object Blob]') {\n\t                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n\t                    if (blobSupport) {\n\t                        return value;\n\t                    }\n\t                    return _encodeBlob(value);\n\t                });\n\t            }\n\t            return value;\n\t        }).then(function (value) {\n\t            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t\n\t                    // The reason we don't _save_ null is because IE 10 does\n\t                    // not support saving the `null` type in IndexedDB. How\n\t                    // ironic, given the bug below!\n\t                    // See: https://github.com/mozilla/localForage/issues/161\n\t                    if (value === null) {\n\t                        value = undefined;\n\t                    }\n\t\n\t                    var req = store.put(value, key);\n\t\n\t                    transaction.oncomplete = function () {\n\t                        // Cast to undefined so the value passed to\n\t                        // callback/promise is the same as what one would get out\n\t                        // of `getItem()` later. This leads to some weirdness\n\t                        // (setItem('foo', undefined) will return `null`), but\n\t                        // it's not my fault localStorage is our baseline and that\n\t                        // it's weird.\n\t                        if (value === undefined) {\n\t                            value = null;\n\t                        }\n\t\n\t                        resolve(value);\n\t                    };\n\t                    transaction.onabort = transaction.onerror = function () {\n\t                        var err = req.error ? req.error : req.transaction.error;\n\t                        reject(err);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction removeItem(key, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    // We use a Grunt task to make this safe for IE and some\n\t                    // versions of Android (including those used by Cordova).\n\t                    // Normally IE won't like `.delete()` and will insist on\n\t                    // using `['delete']()`, but we have a build step that\n\t                    // fixes this for us now.\n\t                    var req = store[\"delete\"](key);\n\t                    transaction.oncomplete = function () {\n\t                        resolve();\n\t                    };\n\t\n\t                    transaction.onerror = function () {\n\t                        reject(req.error);\n\t                    };\n\t\n\t                    // The request will be also be aborted if we've exceeded our storage\n\t                    // space.\n\t                    transaction.onabort = function () {\n\t                        var err = req.error ? req.error : req.transaction.error;\n\t                        reject(err);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction clear(callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    var req = store.clear();\n\t\n\t                    transaction.oncomplete = function () {\n\t                        resolve();\n\t                    };\n\t\n\t                    transaction.onabort = transaction.onerror = function () {\n\t                        var err = req.error ? req.error : req.transaction.error;\n\t                        reject(err);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction length(callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    var req = store.count();\n\t\n\t                    req.onsuccess = function () {\n\t                        resolve(req.result);\n\t                    };\n\t\n\t                    req.onerror = function () {\n\t                        reject(req.error);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction key(n, callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        if (n < 0) {\n\t            resolve(null);\n\t\n\t            return;\n\t        }\n\t\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    var advanced = false;\n\t                    var req = store.openCursor();\n\t\n\t                    req.onsuccess = function () {\n\t                        var cursor = req.result;\n\t                        if (!cursor) {\n\t                            // this means there weren't enough keys\n\t                            resolve(null);\n\t\n\t                            return;\n\t                        }\n\t\n\t                        if (n === 0) {\n\t                            // We have the first key, return it if that's what they\n\t                            // wanted.\n\t                            resolve(cursor.key);\n\t                        } else {\n\t                            if (!advanced) {\n\t                                // Otherwise, ask the cursor to skip ahead n\n\t                                // records.\n\t                                advanced = true;\n\t                                cursor.advance(n);\n\t                            } else {\n\t                                // When we get here, we've got the nth key.\n\t                                resolve(cursor.key);\n\t                            }\n\t                        }\n\t                    };\n\t\n\t                    req.onerror = function () {\n\t                        reject(req.error);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction keys(callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n\t                if (err) {\n\t                    return reject(err);\n\t                }\n\t\n\t                try {\n\t                    var store = transaction.objectStore(self._dbInfo.storeName);\n\t                    var req = store.openCursor();\n\t                    var keys = [];\n\t\n\t                    req.onsuccess = function () {\n\t                        var cursor = req.result;\n\t\n\t                        if (!cursor) {\n\t                            resolve(keys);\n\t                            return;\n\t                        }\n\t\n\t                        keys.push(cursor.key);\n\t                        cursor[\"continue\"]();\n\t                    };\n\t\n\t                    req.onerror = function () {\n\t                        reject(req.error);\n\t                    };\n\t                } catch (e) {\n\t                    reject(e);\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tvar asyncStorage = {\n\t    _driver: 'asyncStorage',\n\t    _initStorage: _initStorage,\n\t    _support: isIndexedDBValid(),\n\t    iterate: iterate,\n\t    getItem: getItem,\n\t    setItem: setItem,\n\t    removeItem: removeItem,\n\t    clear: clear,\n\t    length: length,\n\t    key: key,\n\t    keys: keys\n\t};\n\t\n\tfunction isWebSQLValid() {\n\t    return typeof openDatabase === 'function';\n\t}\n\t\n\t// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n\t// it to Base64, so this is how we store it to prevent very strange errors with less\n\t// verbose ways of binary <-> string data storage.\n\tvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\tvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\n\tvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\t\n\tvar SERIALIZED_MARKER = '__lfsc__:';\n\tvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\t\n\t// OMG the serializations!\n\tvar TYPE_ARRAYBUFFER = 'arbf';\n\tvar TYPE_BLOB = 'blob';\n\tvar TYPE_INT8ARRAY = 'si08';\n\tvar TYPE_UINT8ARRAY = 'ui08';\n\tvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\n\tvar TYPE_INT16ARRAY = 'si16';\n\tvar TYPE_INT32ARRAY = 'si32';\n\tvar TYPE_UINT16ARRAY = 'ur16';\n\tvar TYPE_UINT32ARRAY = 'ui32';\n\tvar TYPE_FLOAT32ARRAY = 'fl32';\n\tvar TYPE_FLOAT64ARRAY = 'fl64';\n\tvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\t\n\tvar toString$1 = Object.prototype.toString;\n\t\n\tfunction stringToBuffer(serializedString) {\n\t    // Fill the string into a ArrayBuffer.\n\t    var bufferLength = serializedString.length * 0.75;\n\t    var len = serializedString.length;\n\t    var i;\n\t    var p = 0;\n\t    var encoded1, encoded2, encoded3, encoded4;\n\t\n\t    if (serializedString[serializedString.length - 1] === '=') {\n\t        bufferLength--;\n\t        if (serializedString[serializedString.length - 2] === '=') {\n\t            bufferLength--;\n\t        }\n\t    }\n\t\n\t    var buffer = new ArrayBuffer(bufferLength);\n\t    var bytes = new Uint8Array(buffer);\n\t\n\t    for (i = 0; i < len; i += 4) {\n\t        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n\t        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n\t        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n\t        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\t\n\t        /*jslint bitwise: true */\n\t        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n\t        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n\t        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n\t    }\n\t    return buffer;\n\t}\n\t\n\t// Converts a buffer to a string to store, serialized, in the backend\n\t// storage library.\n\tfunction bufferToString(buffer) {\n\t    // base64-arraybuffer\n\t    var bytes = new Uint8Array(buffer);\n\t    var base64String = '';\n\t    var i;\n\t\n\t    for (i = 0; i < bytes.length; i += 3) {\n\t        /*jslint bitwise: true */\n\t        base64String += BASE_CHARS[bytes[i] >> 2];\n\t        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n\t        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n\t        base64String += BASE_CHARS[bytes[i + 2] & 63];\n\t    }\n\t\n\t    if (bytes.length % 3 === 2) {\n\t        base64String = base64String.substring(0, base64String.length - 1) + '=';\n\t    } else if (bytes.length % 3 === 1) {\n\t        base64String = base64String.substring(0, base64String.length - 2) + '==';\n\t    }\n\t\n\t    return base64String;\n\t}\n\t\n\t// Serialize a value, afterwards executing a callback (which usually\n\t// instructs the `setItem()` callback/promise to be executed). This is how\n\t// we store binary data with localStorage.\n\tfunction serialize(value, callback) {\n\t    var valueType = '';\n\t    if (value) {\n\t        valueType = toString$1.call(value);\n\t    }\n\t\n\t    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n\t    // checks fail when running the tests using casper.js...\n\t    //\n\t    // TODO: See why those tests fail and use a better solution.\n\t    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n\t        // Convert binary arrays to a string and prefix the string with\n\t        // a special marker.\n\t        var buffer;\n\t        var marker = SERIALIZED_MARKER;\n\t\n\t        if (value instanceof ArrayBuffer) {\n\t            buffer = value;\n\t            marker += TYPE_ARRAYBUFFER;\n\t        } else {\n\t            buffer = value.buffer;\n\t\n\t            if (valueType === '[object Int8Array]') {\n\t                marker += TYPE_INT8ARRAY;\n\t            } else if (valueType === '[object Uint8Array]') {\n\t                marker += TYPE_UINT8ARRAY;\n\t            } else if (valueType === '[object Uint8ClampedArray]') {\n\t                marker += TYPE_UINT8CLAMPEDARRAY;\n\t            } else if (valueType === '[object Int16Array]') {\n\t                marker += TYPE_INT16ARRAY;\n\t            } else if (valueType === '[object Uint16Array]') {\n\t                marker += TYPE_UINT16ARRAY;\n\t            } else if (valueType === '[object Int32Array]') {\n\t                marker += TYPE_INT32ARRAY;\n\t            } else if (valueType === '[object Uint32Array]') {\n\t                marker += TYPE_UINT32ARRAY;\n\t            } else if (valueType === '[object Float32Array]') {\n\t                marker += TYPE_FLOAT32ARRAY;\n\t            } else if (valueType === '[object Float64Array]') {\n\t                marker += TYPE_FLOAT64ARRAY;\n\t            } else {\n\t                callback(new Error('Failed to get type for BinaryArray'));\n\t            }\n\t        }\n\t\n\t        callback(marker + bufferToString(buffer));\n\t    } else if (valueType === '[object Blob]') {\n\t        // Conver the blob to a binaryArray and then to a string.\n\t        var fileReader = new FileReader();\n\t\n\t        fileReader.onload = function () {\n\t            // Backwards-compatible prefix for the blob type.\n\t            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\t\n\t            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n\t        };\n\t\n\t        fileReader.readAsArrayBuffer(value);\n\t    } else {\n\t        try {\n\t            callback(JSON.stringify(value));\n\t        } catch (e) {\n\t            console.error(\"Couldn't convert value into a JSON string: \", value);\n\t\n\t            callback(null, e);\n\t        }\n\t    }\n\t}\n\t\n\t// Deserialize data we've inserted into a value column/field. We place\n\t// special markers into our strings to mark them as encoded; this isn't\n\t// as nice as a meta field, but it's the only sane thing we can do whilst\n\t// keeping localStorage support intact.\n\t//\n\t// Oftentimes this will just deserialize JSON content, but if we have a\n\t// special marker (SERIALIZED_MARKER, defined above), we will extract\n\t// some kind of arraybuffer/binary data/typed array out of the string.\n\tfunction deserialize(value) {\n\t    // If we haven't marked this string as being specially serialized (i.e.\n\t    // something other than serialized JSON), we can just return it and be\n\t    // done with it.\n\t    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n\t        return JSON.parse(value);\n\t    }\n\t\n\t    // The following code deals with deserializing some kind of Blob or\n\t    // TypedArray. First we separate out the type of data we're dealing\n\t    // with from the data itself.\n\t    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n\t    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\t\n\t    var blobType;\n\t    // Backwards-compatible blob type serialization strategy.\n\t    // DBs created with older versions of localForage will simply not have the blob type.\n\t    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n\t        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n\t        blobType = matcher[1];\n\t        serializedString = serializedString.substring(matcher[0].length);\n\t    }\n\t    var buffer = stringToBuffer(serializedString);\n\t\n\t    // Return the right type based on the code/type set during\n\t    // serialization.\n\t    switch (type) {\n\t        case TYPE_ARRAYBUFFER:\n\t            return buffer;\n\t        case TYPE_BLOB:\n\t            return createBlob([buffer], { type: blobType });\n\t        case TYPE_INT8ARRAY:\n\t            return new Int8Array(buffer);\n\t        case TYPE_UINT8ARRAY:\n\t            return new Uint8Array(buffer);\n\t        case TYPE_UINT8CLAMPEDARRAY:\n\t            return new Uint8ClampedArray(buffer);\n\t        case TYPE_INT16ARRAY:\n\t            return new Int16Array(buffer);\n\t        case TYPE_UINT16ARRAY:\n\t            return new Uint16Array(buffer);\n\t        case TYPE_INT32ARRAY:\n\t            return new Int32Array(buffer);\n\t        case TYPE_UINT32ARRAY:\n\t            return new Uint32Array(buffer);\n\t        case TYPE_FLOAT32ARRAY:\n\t            return new Float32Array(buffer);\n\t        case TYPE_FLOAT64ARRAY:\n\t            return new Float64Array(buffer);\n\t        default:\n\t            throw new Error('Unkown type: ' + type);\n\t    }\n\t}\n\t\n\tvar localforageSerializer = {\n\t    serialize: serialize,\n\t    deserialize: deserialize,\n\t    stringToBuffer: stringToBuffer,\n\t    bufferToString: bufferToString\n\t};\n\t\n\t/*\n\t * Includes code from:\n\t *\n\t * base64-arraybuffer\n\t * https://github.com/niklasvh/base64-arraybuffer\n\t *\n\t * Copyright (c) 2012 Niklas von Hertzen\n\t * Licensed under the MIT license.\n\t */\n\t// Open the WebSQL database (automatically creates one if one didn't\n\t// previously exist), using any options set in the config.\n\tfunction _initStorage$1(options) {\n\t    var self = this;\n\t    var dbInfo = {\n\t        db: null\n\t    };\n\t\n\t    if (options) {\n\t        for (var i in options) {\n\t            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n\t        }\n\t    }\n\t\n\t    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n\t        // Open the database; the openDatabase API will automatically\n\t        // create it for us if it doesn't exist.\n\t        try {\n\t            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n\t        } catch (e) {\n\t            return reject(e);\n\t        }\n\t\n\t        // Create our key/value table if it doesn't exist.\n\t        dbInfo.db.transaction(function (t) {\n\t            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n\t                self._dbInfo = dbInfo;\n\t                resolve();\n\t            }, function (t, error) {\n\t                reject(error);\n\t            });\n\t        });\n\t    });\n\t\n\t    dbInfo.serializer = localforageSerializer;\n\t    return dbInfoPromise;\n\t}\n\t\n\tfunction getItem$1(key, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n\t                    var result = results.rows.length ? results.rows.item(0).value : null;\n\t\n\t                    // Check to see if this is serialized content we need to\n\t                    // unpack.\n\t                    if (result) {\n\t                        result = dbInfo.serializer.deserialize(result);\n\t                    }\n\t\n\t                    resolve(result);\n\t                }, function (t, error) {\n\t\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction iterate$1(iterator, callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n\t                    var rows = results.rows;\n\t                    var length = rows.length;\n\t\n\t                    for (var i = 0; i < length; i++) {\n\t                        var item = rows.item(i);\n\t                        var result = item.value;\n\t\n\t                        // Check to see if this is serialized content\n\t                        // we need to unpack.\n\t                        if (result) {\n\t                            result = dbInfo.serializer.deserialize(result);\n\t                        }\n\t\n\t                        result = iterator(result, item.key, i + 1);\n\t\n\t                        // void(0) prevents problems with redefinition\n\t                        // of `undefined`.\n\t                        if (result !== void 0) {\n\t                            resolve(result);\n\t                            return;\n\t                        }\n\t                    }\n\t\n\t                    resolve();\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction _setItem(key, value, callback, retriesLeft) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            // The localStorage API doesn't return undefined values in an\n\t            // \"expected\" way, so undefined is always cast to null in all\n\t            // drivers. See: https://github.com/mozilla/localForage/pull/42\n\t            if (value === undefined) {\n\t                value = null;\n\t            }\n\t\n\t            // Save the original value to pass to the callback.\n\t            var originalValue = value;\n\t\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.serializer.serialize(value, function (value, error) {\n\t                if (error) {\n\t                    reject(error);\n\t                } else {\n\t                    dbInfo.db.transaction(function (t) {\n\t                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n\t                            resolve(originalValue);\n\t                        }, function (t, error) {\n\t                            reject(error);\n\t                        });\n\t                    }, function (sqlError) {\n\t                        // The transaction failed; check\n\t                        // to see if it's a quota error.\n\t                        if (sqlError.code === sqlError.QUOTA_ERR) {\n\t                            // We reject the callback outright for now, but\n\t                            // it's worth trying to re-run the transaction.\n\t                            // Even if the user accepts the prompt to use\n\t                            // more storage on Safari, this error will\n\t                            // be called.\n\t                            //\n\t                            // Try to re-run the transaction.\n\t                            if (retriesLeft > 0) {\n\t                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n\t                                return;\n\t                            }\n\t                            reject(sqlError);\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction setItem$1(key, value, callback) {\n\t    return _setItem.apply(this, [key, value, callback, 1]);\n\t}\n\t\n\tfunction removeItem$1(key, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n\t                    resolve();\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Deletes every item in the table.\n\t// TODO: Find out if this resets the AUTO_INCREMENT number.\n\tfunction clear$1(callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n\t                    resolve();\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Does a simple `COUNT(key)` to get the number of items stored in\n\t// localForage.\n\tfunction length$1(callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                // Ahhh, SQL makes this one soooooo easy.\n\t                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n\t                    var result = results.rows.item(0).c;\n\t\n\t                    resolve(result);\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Return the key located at key index X; essentially gets the key from a\n\t// `WHERE id = ?`. This is the most efficient way I can think to implement\n\t// this rarely-used (in my experience) part of the API, but it can seem\n\t// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n\t// the ID of each key will change every time it's updated. Perhaps a stored\n\t// procedure for the `setItem()` SQL would solve this problem?\n\t// TODO: Don't change ID on `setItem()`.\n\tfunction key$1(n, callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n\t                    var result = results.rows.length ? results.rows.item(0).key : null;\n\t                    resolve(result);\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction keys$1(callback) {\n\t    var self = this;\n\t\n\t    var promise = new Promise$1(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n\t                    var keys = [];\n\t\n\t                    for (var i = 0; i < results.rows.length; i++) {\n\t                        keys.push(results.rows.item(i).key);\n\t                    }\n\t\n\t                    resolve(keys);\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        })[\"catch\"](reject);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tvar webSQLStorage = {\n\t    _driver: 'webSQLStorage',\n\t    _initStorage: _initStorage$1,\n\t    _support: isWebSQLValid(),\n\t    iterate: iterate$1,\n\t    getItem: getItem$1,\n\t    setItem: setItem$1,\n\t    removeItem: removeItem$1,\n\t    clear: clear$1,\n\t    length: length$1,\n\t    key: key$1,\n\t    keys: keys$1\n\t};\n\t\n\tfunction isLocalStorageValid() {\n\t    try {\n\t        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && typeof localStorage.setItem === 'function';\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\t// Check if localStorage throws when saving an item\n\tfunction checkIfLocalStorageThrows() {\n\t    var localStorageTestKey = '_localforage_support_test';\n\t\n\t    try {\n\t        localStorage.setItem(localStorageTestKey, true);\n\t        localStorage.removeItem(localStorageTestKey);\n\t\n\t        return false;\n\t    } catch (e) {\n\t        return true;\n\t    }\n\t}\n\t\n\t// Check if localStorage is usable and allows to save an item\n\t// This method checks if localStorage is usable in Safari Private Browsing\n\t// mode, or in any other case where the available quota for localStorage\n\t// is 0 and there wasn't any saved items yet.\n\tfunction _isLocalStorageUsable() {\n\t    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n\t}\n\t\n\t// Config the localStorage backend, using options set in the config.\n\tfunction _initStorage$2(options) {\n\t    var self = this;\n\t    var dbInfo = {};\n\t    if (options) {\n\t        for (var i in options) {\n\t            dbInfo[i] = options[i];\n\t        }\n\t    }\n\t\n\t    dbInfo.keyPrefix = dbInfo.name + '/';\n\t\n\t    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n\t        dbInfo.keyPrefix += dbInfo.storeName + '/';\n\t    }\n\t\n\t    if (!_isLocalStorageUsable()) {\n\t        return Promise$1.reject();\n\t    }\n\t\n\t    self._dbInfo = dbInfo;\n\t    dbInfo.serializer = localforageSerializer;\n\t\n\t    return Promise$1.resolve();\n\t}\n\t\n\t// Remove all keys from the datastore, effectively destroying all data in\n\t// the app's key/value store!\n\tfunction clear$2(callback) {\n\t    var self = this;\n\t    var promise = self.ready().then(function () {\n\t        var keyPrefix = self._dbInfo.keyPrefix;\n\t\n\t        for (var i = localStorage.length - 1; i >= 0; i--) {\n\t            var key = localStorage.key(i);\n\t\n\t            if (key.indexOf(keyPrefix) === 0) {\n\t                localStorage.removeItem(key);\n\t            }\n\t        }\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Retrieve an item from the store. Unlike the original async_storage\n\t// library in Gaia, we don't modify return values at all. If a key's value\n\t// is `undefined`, we pass that value to the callback function.\n\tfunction getItem$2(key, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\t\n\t        // If a result was found, parse it from the serialized\n\t        // string into a JS object. If result isn't truthy, the key\n\t        // is likely undefined and we'll pass it straight to the\n\t        // callback.\n\t        if (result) {\n\t            result = dbInfo.serializer.deserialize(result);\n\t        }\n\t\n\t        return result;\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Iterate over all items in the store.\n\tfunction iterate$2(iterator, callback) {\n\t    var self = this;\n\t\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var keyPrefix = dbInfo.keyPrefix;\n\t        var keyPrefixLength = keyPrefix.length;\n\t        var length = localStorage.length;\n\t\n\t        // We use a dedicated iterator instead of the `i` variable below\n\t        // so other keys we fetch in localStorage aren't counted in\n\t        // the `iterationNumber` argument passed to the `iterate()`\n\t        // callback.\n\t        //\n\t        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n\t        var iterationNumber = 1;\n\t\n\t        for (var i = 0; i < length; i++) {\n\t            var key = localStorage.key(i);\n\t            if (key.indexOf(keyPrefix) !== 0) {\n\t                continue;\n\t            }\n\t            var value = localStorage.getItem(key);\n\t\n\t            // If a result was found, parse it from the serialized\n\t            // string into a JS object. If result isn't truthy, the\n\t            // key is likely undefined and we'll pass it straight\n\t            // to the iterator.\n\t            if (value) {\n\t                value = dbInfo.serializer.deserialize(value);\n\t            }\n\t\n\t            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\t\n\t            if (value !== void 0) {\n\t                return value;\n\t            }\n\t        }\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Same as localStorage's key() method, except takes a callback.\n\tfunction key$2(n, callback) {\n\t    var self = this;\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var result;\n\t        try {\n\t            result = localStorage.key(n);\n\t        } catch (error) {\n\t            result = null;\n\t        }\n\t\n\t        // Remove the prefix from the key, if a key is found.\n\t        if (result) {\n\t            result = result.substring(dbInfo.keyPrefix.length);\n\t        }\n\t\n\t        return result;\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction keys$2(callback) {\n\t    var self = this;\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var length = localStorage.length;\n\t        var keys = [];\n\t\n\t        for (var i = 0; i < length; i++) {\n\t            var itemKey = localStorage.key(i);\n\t            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n\t                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n\t            }\n\t        }\n\t\n\t        return keys;\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Supply the number of keys in the datastore to the callback function.\n\tfunction length$2(callback) {\n\t    var self = this;\n\t    var promise = self.keys().then(function (keys) {\n\t        return keys.length;\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Remove an item from the store, nice and simple.\n\tfunction removeItem$2(key, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        localStorage.removeItem(dbInfo.keyPrefix + key);\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Set a key's value and run an optional callback once the value is set.\n\t// Unlike Gaia's implementation, the callback function is passed the value,\n\t// in case you want to operate on that value only after you're sure it\n\t// saved, or something like that.\n\tfunction setItem$2(key, value, callback) {\n\t    var self = this;\n\t\n\t    key = normalizeKey(key);\n\t\n\t    var promise = self.ready().then(function () {\n\t        // Convert undefined values to null.\n\t        // https://github.com/mozilla/localForage/pull/42\n\t        if (value === undefined) {\n\t            value = null;\n\t        }\n\t\n\t        // Save the original value to pass to the callback.\n\t        var originalValue = value;\n\t\n\t        return new Promise$1(function (resolve, reject) {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.serializer.serialize(value, function (value, error) {\n\t                if (error) {\n\t                    reject(error);\n\t                } else {\n\t                    try {\n\t                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n\t                        resolve(originalValue);\n\t                    } catch (e) {\n\t                        // localStorage capacity exceeded.\n\t                        // TODO: Make this a specific error/event.\n\t                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n\t                            reject(e);\n\t                        }\n\t                        reject(e);\n\t                    }\n\t                }\n\t            });\n\t        });\n\t    });\n\t\n\t    executeCallback(promise, callback);\n\t    return promise;\n\t}\n\t\n\tvar localStorageWrapper = {\n\t    _driver: 'localStorageWrapper',\n\t    _initStorage: _initStorage$2,\n\t    _support: isLocalStorageValid(),\n\t    iterate: iterate$2,\n\t    getItem: getItem$2,\n\t    setItem: setItem$2,\n\t    removeItem: removeItem$2,\n\t    clear: clear$2,\n\t    length: length$2,\n\t    key: key$2,\n\t    keys: keys$2\n\t};\n\t\n\tvar isArray = Array.isArray || function (arg) {\n\t    return Object.prototype.toString.call(arg) === '[object Array]';\n\t};\n\t\n\t// Drivers are stored here when `defineDriver()` is called.\n\t// They are shared across all instances of localForage.\n\tvar DefinedDrivers = {};\n\t\n\tvar DriverSupport = {};\n\t\n\tvar DefaultDrivers = {\n\t    INDEXEDDB: asyncStorage,\n\t    WEBSQL: webSQLStorage,\n\t    LOCALSTORAGE: localStorageWrapper\n\t};\n\t\n\tvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\t\n\tvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\t\n\tvar DefaultConfig = {\n\t    description: '',\n\t    driver: DefaultDriverOrder.slice(),\n\t    name: 'localforage',\n\t    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n\t    // we can use without a prompt.\n\t    size: 4980736,\n\t    storeName: 'keyvaluepairs',\n\t    version: 1.0\n\t};\n\t\n\tfunction callWhenReady(localForageInstance, libraryMethod) {\n\t    localForageInstance[libraryMethod] = function () {\n\t        var _args = arguments;\n\t        return localForageInstance.ready().then(function () {\n\t            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n\t        });\n\t    };\n\t}\n\t\n\tfunction extend() {\n\t    for (var i = 1; i < arguments.length; i++) {\n\t        var arg = arguments[i];\n\t\n\t        if (arg) {\n\t            for (var _key in arg) {\n\t                if (arg.hasOwnProperty(_key)) {\n\t                    if (isArray(arg[_key])) {\n\t                        arguments[0][_key] = arg[_key].slice();\n\t                    } else {\n\t                        arguments[0][_key] = arg[_key];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return arguments[0];\n\t}\n\t\n\tvar LocalForage = function () {\n\t    function LocalForage(options) {\n\t        _classCallCheck(this, LocalForage);\n\t\n\t        for (var driverTypeKey in DefaultDrivers) {\n\t            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n\t                var driver = DefaultDrivers[driverTypeKey];\n\t                var driverName = driver._driver;\n\t                this[driverTypeKey] = driverName;\n\t\n\t                if (!DefinedDrivers[driverName]) {\n\t                    // we don't need to wait for the promise,\n\t                    // since the default drivers can be defined\n\t                    // in a blocking manner\n\t                    this.defineDriver(driver);\n\t                }\n\t            }\n\t        }\n\t\n\t        this._defaultConfig = extend({}, DefaultConfig);\n\t        this._config = extend({}, this._defaultConfig, options);\n\t        this._driverSet = null;\n\t        this._initDriver = null;\n\t        this._ready = false;\n\t        this._dbInfo = null;\n\t\n\t        this._wrapLibraryMethodsWithReady();\n\t        this.setDriver(this._config.driver)[\"catch\"](function () {});\n\t    }\n\t\n\t    // Set any config values for localForage; can be called anytime before\n\t    // the first API call (e.g. `getItem`, `setItem`).\n\t    // We loop through options so we don't overwrite existing config\n\t    // values.\n\t\n\t\n\t    LocalForage.prototype.config = function config(options) {\n\t        // If the options argument is an object, we use it to set values.\n\t        // Otherwise, we return either a specified config value or all\n\t        // config values.\n\t        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n\t            // If localforage is ready and fully initialized, we can't set\n\t            // any new configuration values. Instead, we return an error.\n\t            if (this._ready) {\n\t                return new Error('Can\\'t call config() after localforage ' + 'has been used.');\n\t            }\n\t\n\t            for (var i in options) {\n\t                if (i === 'storeName') {\n\t                    options[i] = options[i].replace(/\\W/g, '_');\n\t                }\n\t\n\t                if (i === 'version' && typeof options[i] !== 'number') {\n\t                    return new Error('Database version must be a number.');\n\t                }\n\t\n\t                this._config[i] = options[i];\n\t            }\n\t\n\t            // after all config options are set and\n\t            // the driver option is used, try setting it\n\t            if ('driver' in options && options.driver) {\n\t                return this.setDriver(this._config.driver);\n\t            }\n\t\n\t            return true;\n\t        } else if (typeof options === 'string') {\n\t            return this._config[options];\n\t        } else {\n\t            return this._config;\n\t        }\n\t    };\n\t\n\t    // Used to define a custom driver, shared across all instances of\n\t    // localForage.\n\t\n\t\n\t    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n\t        var promise = new Promise$1(function (resolve, reject) {\n\t            try {\n\t                var driverName = driverObject._driver;\n\t                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\t\n\t                // A driver name should be defined and not overlap with the\n\t                // library-defined, default drivers.\n\t                if (!driverObject._driver) {\n\t                    reject(complianceError);\n\t                    return;\n\t                }\n\t\n\t                var driverMethods = LibraryMethods.concat('_initStorage');\n\t                for (var i = 0, len = driverMethods.length; i < len; i++) {\n\t                    var customDriverMethod = driverMethods[i];\n\t                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n\t                        reject(complianceError);\n\t                        return;\n\t                    }\n\t                }\n\t\n\t                var setDriverSupport = function setDriverSupport(support) {\n\t                    if (DefinedDrivers[driverName]) {\n\t                        console.info('Redefining LocalForage driver: ' + driverName);\n\t                    }\n\t                    DefinedDrivers[driverName] = driverObject;\n\t                    DriverSupport[driverName] = support;\n\t                    // don't use a then, so that we can define\n\t                    // drivers that have simple _support methods\n\t                    // in a blocking manner\n\t                    resolve();\n\t                };\n\t\n\t                if ('_support' in driverObject) {\n\t                    if (driverObject._support && typeof driverObject._support === 'function') {\n\t                        driverObject._support().then(setDriverSupport, reject);\n\t                    } else {\n\t                        setDriverSupport(!!driverObject._support);\n\t                    }\n\t                } else {\n\t                    setDriverSupport(true);\n\t                }\n\t            } catch (e) {\n\t                reject(e);\n\t            }\n\t        });\n\t\n\t        executeTwoCallbacks(promise, callback, errorCallback);\n\t        return promise;\n\t    };\n\t\n\t    LocalForage.prototype.driver = function driver() {\n\t        return this._driver || null;\n\t    };\n\t\n\t    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n\t        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\t\n\t        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n\t        return getDriverPromise;\n\t    };\n\t\n\t    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n\t        var serializerPromise = Promise$1.resolve(localforageSerializer);\n\t        executeTwoCallbacks(serializerPromise, callback);\n\t        return serializerPromise;\n\t    };\n\t\n\t    LocalForage.prototype.ready = function ready(callback) {\n\t        var self = this;\n\t\n\t        var promise = self._driverSet.then(function () {\n\t            if (self._ready === null) {\n\t                self._ready = self._initDriver();\n\t            }\n\t\n\t            return self._ready;\n\t        });\n\t\n\t        executeTwoCallbacks(promise, callback, callback);\n\t        return promise;\n\t    };\n\t\n\t    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n\t        var self = this;\n\t\n\t        if (!isArray(drivers)) {\n\t            drivers = [drivers];\n\t        }\n\t\n\t        var supportedDrivers = this._getSupportedDrivers(drivers);\n\t\n\t        function setDriverToConfig() {\n\t            self._config.driver = self.driver();\n\t        }\n\t\n\t        function extendSelfWithDriver(driver) {\n\t            self._extend(driver);\n\t            setDriverToConfig();\n\t\n\t            self._ready = self._initStorage(self._config);\n\t            return self._ready;\n\t        }\n\t\n\t        function initDriver(supportedDrivers) {\n\t            return function () {\n\t                var currentDriverIndex = 0;\n\t\n\t                function driverPromiseLoop() {\n\t                    while (currentDriverIndex < supportedDrivers.length) {\n\t                        var driverName = supportedDrivers[currentDriverIndex];\n\t                        currentDriverIndex++;\n\t\n\t                        self._dbInfo = null;\n\t                        self._ready = null;\n\t\n\t                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n\t                    }\n\t\n\t                    setDriverToConfig();\n\t                    var error = new Error('No available storage method found.');\n\t                    self._driverSet = Promise$1.reject(error);\n\t                    return self._driverSet;\n\t                }\n\t\n\t                return driverPromiseLoop();\n\t            };\n\t        }\n\t\n\t        // There might be a driver initialization in progress\n\t        // so wait for it to finish in order to avoid a possible\n\t        // race condition to set _dbInfo\n\t        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n\t            return Promise$1.resolve();\n\t        }) : Promise$1.resolve();\n\t\n\t        this._driverSet = oldDriverSetDone.then(function () {\n\t            var driverName = supportedDrivers[0];\n\t            self._dbInfo = null;\n\t            self._ready = null;\n\t\n\t            return self.getDriver(driverName).then(function (driver) {\n\t                self._driver = driver._driver;\n\t                setDriverToConfig();\n\t                self._wrapLibraryMethodsWithReady();\n\t                self._initDriver = initDriver(supportedDrivers);\n\t            });\n\t        })[\"catch\"](function () {\n\t            setDriverToConfig();\n\t            var error = new Error('No available storage method found.');\n\t            self._driverSet = Promise$1.reject(error);\n\t            return self._driverSet;\n\t        });\n\t\n\t        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n\t        return this._driverSet;\n\t    };\n\t\n\t    LocalForage.prototype.supports = function supports(driverName) {\n\t        return !!DriverSupport[driverName];\n\t    };\n\t\n\t    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n\t        extend(this, libraryMethodsAndProperties);\n\t    };\n\t\n\t    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n\t        var supportedDrivers = [];\n\t        for (var i = 0, len = drivers.length; i < len; i++) {\n\t            var driverName = drivers[i];\n\t            if (this.supports(driverName)) {\n\t                supportedDrivers.push(driverName);\n\t            }\n\t        }\n\t        return supportedDrivers;\n\t    };\n\t\n\t    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n\t        // Add a stub for each driver API method that delays the call to the\n\t        // corresponding driver method until localForage is ready. These stubs\n\t        // will be replaced by the driver methods as soon as the driver is\n\t        // loaded, so there is no performance impact.\n\t        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n\t            callWhenReady(this, LibraryMethods[i]);\n\t        }\n\t    };\n\t\n\t    LocalForage.prototype.createInstance = function createInstance(options) {\n\t        return new LocalForage(options);\n\t    };\n\t\n\t    return LocalForage;\n\t}();\n\t\n\t// The actual localForage object that we expose as a module or via a\n\t// global. It's extended by pulling in one of our other libraries.\n\t\n\t\n\tvar localforage_js = new LocalForage();\n\t\n\tmodule.exports = localforage_js;\n\t\n\t},{\"3\":3}]},{},[4])(4)\n\t});\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6dbbd6a780c64df31844","/* eslint-env serviceworker */\n\nimport localForage from 'localforage'\n\nfunction isEnabled () {\n  return localForage.getItem('vuex-lz')\n    .then(data => data.config.webPushNotifications)\n}\n\nfunction getWindowClients () {\n  return clients.matchAll({ includeUncontrolled: true })\n    .then((clientList) => clientList.filter(({ type }) => type === 'window'))\n}\n\nself.addEventListener('push', (event) => {\n  if (event.data) {\n    event.waitUntil(isEnabled().then((isEnabled) => {\n      return isEnabled && getWindowClients().then((list) => {\n        const data = event.data.json()\n\n        if (list.length === 0) return self.registration.showNotification(data.title, data)\n      })\n    }))\n  }\n})\n\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close()\n\n  event.waitUntil(getWindowClients().then((list) => {\n    for (var i = 0; i < list.length; i++) {\n      var client = list[i]\n      if (client.url === '/' && 'focus' in client) { return client.focus() }\n    }\n\n    if (clients.openWindow) return clients.openWindow('/')\n  }))\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/sw.js","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.6\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        if (forages[i]._dbInfo.db) {\n            forages[i]._dbInfo.db.close();\n            forages[i]._dbInfo.db = null;\n        }\n    }\n\n    return _getConnection(dbInfo, false).then(function (db) {\n        for (var j = 0; j < forages.length; j++) {\n            forages[j]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback) {\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (!dbInfo.db || err.name === 'InvalidStateError') {\n            return _tryReconnect(dbInfo).then(function () {\n\n                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                callback(null, tx);\n            });\n        }\n\n        callback(err);\n    }\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback retuns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && typeof localStorage.setItem === 'function';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error('Can\\'t call config() after localforage ' + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var customDriverMethod = driverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/localforage/dist/localforage.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}